Multi Threading:
================
Multi Tasking:
==============
* The process of executing several tasks simentaniously is called multitasking.

Multitaking is divided into two categories:
===========================================
1. process based multi tasking
2. thread based multi tasking

1. Process based multi tasking:
===============================
* Executing several tasks simentaniously where each task  is a seperate independent program or process.
ex: 1. typing java program in ide
	2. listen audio 
	3. downloading a file from net.
	
* perform simentaniously but there is no dependent on each other.
* this kind of multitasking applicable for os level.

2. Thread based multitasking:
=============================
* Executing serveral tasks simentaniously where each task is a seperate independent part of the same program or process is called thread based multitasking.
* Each independent part is called "Thread".

Application areas of multithreading are:
========================================
1. to develop animations.
2. to develop vedio games.
3. to develop web&application servers.


Thread:
=======
Thread is a flow of execution for every thread there is a seperate independent job.

ways to define a thread:
========================
1. By extending Thread Class.
2. By implementing Runnable Interface.

1. By extending thread Class:
=============================
ex:

case1:Thread Scheduler:
========================
* It is responsible for schedule the threads i,e if multiple threads are waiting to get a chance of execution then in which order threads will be executed is decided by thread scheduler

case2: difference between t.start() and t.run():
================================================
* In the case of t.start() a new thread is created which is the responsible for execution of run method.
* but in case of t.run() new thread wont create and run() method will call just like normal methodcall by main thread. Hence o/p will child thread followed by main thread.

case3: importance if thread class start method:
===============================================
* Thread class start method is responsible to register with the Thread Scheduler & all other manditary activities hence without executing the Thread class start() method there is no chance of starting a new thread in java
* due to this thread class "start()" method is considered as heart of multithreading.

case4:
======
* overloading run method is always possible but thread class start() method can invoke no-args run method.
* other will call normall using method call by main thread.
* same way main method overloading is possibel bu jvm will exucute (String[] args)

case5: if we not override run method:
=====================================
class MyThread extends Thread{
	
}
* Thread class run method will be executed which as empty implementation. Hence we won't get any o/p.


case6: overriding start() method:
=================================
* it will be executed just like normale method call.
* it si not recomended.

case7: overriding start() method and when we call super.start():
=================================================
* o/p nit expected.

case8: life cycle of thread:
============================
new/born thread  t.start()   run/runnable state  
				----------> 					
if thraed scheduler allocates processor     running state
----------------------------------------->
if run() method completed  dead state
------------------------->  

* this is simple life cycle of thread

case9:Imp
-========
* After starting a thread if we are trying to restart same thread then we wil get RE saying illegalThreadStateException. 


2. Defining a Thread by implementing Runnable interface:
========================================================
* the runnale interface present in java.lang package & it contains only one method run().

					     Runnable
						^         ^
						|          |
						|		implements
						|			|
			already implements        MyThread
				|
			Thraed
			^
			|
		  extends
			|
		MyThread
		
		
* Which Approach is best :
==========================
* Amoung two ways of defining a thread implements runnnable approach is recomended.

* In the first approach our class always extends Thread class, there is no chance extending any other class we lost inheritence.
* but in 2 way we can extend any other class  here we won't misss inheritence benifit so here this is recomended.

Getting & Setting name of a Thread:
===================================
* Every thread in java has some name. it may default name generated by jvm or customized name given by programmer.
* we can get & set a name if therad using following two methods.
1. public final String getName();
2. public final void setName(String name);
ex:
===
class MyThread extends Thread(){
}
psvm(){
	syso(Thread.currentThread().getName());
	MyThread t= new MyThread();
	syso(t.getName());
	Thread.currentThread().setName("hello");
	syso(Thread.currentThread().getName());
}

* when exception generate it will tell "exception in hello" not main.
* we cna get current executing thread object usign Thread.currentThread().
ex:
===
using Thread.currentThread().getName();

Thread priorities:
==================
* Every thread in java has some priority it may br default generated by jvm or customized priority given by programmer.

* The valid range if thread priority 1 to 10. where 1 is min priority and 10 is max priority.

Thread.MIN_PRIORITY - 1
Thread.NORM_PRIORITY - 5
Thread.MAX_PRIORITY - 10

* thread scheduler will use these priorities while allocating processor.
* thread having heighest priority this will get chance first.
* if two thread as same priority we cann't except the execution order it will depends on "thraed scheduler"

* following methods.
1. public final int getPriority();
2. public final void setPriority(int p);

ex:
===
t.setPriority(2); - correct
t.setPriority(17); - RE IllegalArgumentException

* Default priority of main thread - 5.
* for all thread default priority inherited from parent to child (same as parent).
*some platform won't support for priorities.
ex:
===
using getPriority and setPriority - for child setPriority(10)


The method to prevent thread execution:
=======================================
1. yield();
2. join();
3. sleep();


1. yield:
=========
* cause too puse the current executing thread to give the chance for waiting threads of same priority. if there is no waiting thread or all waiting threads have low priority then same thread can continue ots exception.

* If multiple threads are waiting with same prioprity then which waiting thread will get a chance we can't expect it depends on thread seceduler.

* prototype:
============
public static native void yield(); - native means not implemented in java.
										Thread.yeild()
										|
new/born thread  t.start()   run/runnable state  |
				----------> 					 |
if thraed scheduler allocates processor     running state
----------------------------------------->
if run() method completed  dead state
------------------------->  
ex:
===
class MyThread extends Thread{
	p v run(){
		for(int i=0;i<10;i++){
			sys("Child");
			Thraed.yeild();
		}
	}
}
* o/p here thread always yeild() now main will more chance than child thread.

2. join():
==========
* If thread wants to wait until completing some other thread then we should go for join() method.

for ex:
=======
* If a thread t1 wants to wait until completing t2 then t1 has to call [t2.join()].
* If t1 executes [t2.join] then immediately t1 is entered into waiting state/block state(for join) until t2 completes.

prototype:
==========
public final void join();thrown Interpted Exception
public final void join(long ms);
public final void join(long ms, int ns);
* we need to handle with try chatch or thows keyword

* every join method throws interpted execption compulrosy  
we shpuld hanlde exception using catch or throws else get CE.

								|-----Waiting state
					if t1 completes					|
					if time expries				t1.join()
					if waiting thared got interputed.			t1.join(2000);
								|		t1.join(2000,1000);
								|		
								|
new/born thread  t.start()   run/runnable state  	|
				----------> 						|
if thraed scheduler allocates processor     running state
----------------------------------------->		
if run() method completed  dead state			
------------------------->  					
													
													
ex:
===
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 3; i++) {
            try {
                Thread.sleep(500);  // just to slow down execution
            } catch (InterruptedException e) {
                System.out.println(" interrupted.");
            }
        }
        System.out.println(" finished.");
    }
}

public class JoinExample {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();

        t1.start();
        try {
            t1.join();  // main thread waits until t1 finishes
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("All threads finished. Main thread ends.");
    }
}


case2: waiting if child thread until completing main thread:
=====================================================
class myThread extends Thread{
	static Thread mt;
	public void run(){
		try{
			mt.join();
		}catch(){
		
		}
		//code
	}
}

class threadjoin(){
	psvm(){
		myThread.mt = Thread.currentThread();
		myThread t =new myThread();
		t.start();
		for(int i=0; i<10;i++){
			syso("main thread");
			Thread.sleep(2000);
		}
	}
}

* Here child thread waits until main thread completion.

case3:
======
* If main thread calls join() method on child thread object and child thread calles the join method on main thread object & the proggram will be stucked this is something like "deadlock".

case4:
======
Thread class join method on a same thred itself then the program will stucked is something like "deadlock".
ex:
===
classs test{
	psvm(){
		Thread.currentThread().join();
		syso("main thread");
	}
}

3. sleep():
===========
* If thread do not want to perform any operation for a perticular amount of time then we should go for "sleep()" method.

prototype:
==========
public static native void sleep(long ms) throws IE;
public static void sleep(long ms, int ns) throws IE;

1 millisecond = 1,000,000 nanoseconds,
1000 ms = 1 second

ns range(0–999,999)


diagram
=======

ex:
===

how a thread can interrupte the another thread:
===============================================
* A thread can interupt a  sleeping thread or a waiting thread by using "interupt()"method of thread class.
prototype:
==========
public void interrupt();

ex:
===
class MyThread extends Thread {
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Thread running... iteration " + i);
                Thread.sleep(1000); // Simulate some work
            }
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted! Cleaning up...");
        }
        System.out.println("Thread ends.");
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();

        try {
            Thread.sleep(3000); // Let the thread run for a while
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Main thread interrupts child thread.");
        t.interrupt();  // Interrupt the thread
    }
}

cases:
======
* when ever we calling interrupt method if the target thread not in sleeping state or waiting state.then there is no implact of interrupt call immediately enterupted call will be waited until targets thread entered into sleepling or waiting state.
* If the target thread enter into sleeping or waiting state then immediately interpt call will interpt the target thread.
* If the target thread never entered into sleeping or waiting state in its life cycle then tere is no interupt call this is the only case interrupt caall will be wasted.

class MyThread extends Thread {
    public void run() {
	for (int i = 1; i <= 10000; i++) {
                System.out.println("Thread running... iteration " + i);
             
            }
        try {
               Thread.sleep(1000); // Simulate some work
        } catch (InterruptedException e) {
            System.out.println("Thread was interrupted! Cleaning up...");
        }
        System.out.println("Thread ends.");
    }
}

public class InterruptExample {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start();
        System.out.println("Main thread interrupts child thread.");
        t.interrupt();  // Interrupt the thread
    }
}
* In the above example "interupt call" waiteed until child thread completes for loop 10,000 times.


Differences:
============
1. Yeild(): if a thread wants to pause its execution to give the chance for tha remain threads of same priority then go for yeild().

2. Join(): if a thread wants to wait until completing some other thread then we should go for join method.

3. Sleep(): if a thread don't perform any operaion per a perticular amount of time then we should for for sleep method.

Synchronization:
================
* Synchronized is the modifier applicable only for methods & blocks but not for classes and variables.
* If multiple threads are trying to operate saimentaneously
on the same java object then three may be a chance of "data inconsistency problem". to over come we should go for "synchronized" keyword.
* Internally synchronization concept is implemented by using lock, every object in java has a unique lock. when ever we are using synchronized keyword then only lock concept come into picture.
* If thread wants to execute synchronized method on the given object first it has to get lockof that object once thread got the lock then it is allowed to execute any synchronized method on that object.
* Once method is completed automatically thread releases lock threads are allowed to executes non-synchronized methods 
* accuring and relaseing lock is taken care by jvm and programmer is not responsible.
* while thread executing synchronized method on the given object the remaining threads are not allowed to executes any synchronized method simultaneously on the same object but remaing simultaneously.
* lock conecpt is implemented based on object not method.
* every objetc ahs two state sync and non-sync 

prototype:
==========
class X{
	synchronized{
		where ever we performs update operation add|rename|delete i,e where state of object is changing.
	}
	non-sync{
		where every object won't be changes like read().
	}
}

ex:
===
class Display{
	public void wish(String name){ // do for synchronized
		for(int i=0;i<10;i++){
			syso("good morning");
			try{
				Thread.sleep(2000);
			}
			catch(Interrupt Exception e){
			}
			syso(name);
		}
	}
}
class MyThread extends Thread{
	Display d;
	String name;
	MyThread(Display d , String s){
		this.d=d;
		this.s=s;
	}
	public void run(){
		d.wish(name);
	}
}
class Main{
	psvm(){
		Display d = new Display();
		MyThread t1 = new MyThread(d,"mohan");
		MyThread t2 = new MyThread(d,"yuvaraj");
		t1.start();
		t2.start();
	}
}

case1:
======
different objects
class Main{
	psvm(){
		Display d1 = new Display();
		Display d2 = new Display();
		MyThread t1 = new MyThread(d1,"mohan");
		MyThread t2 = new MyThread(d2,"yuvaraj");
		t1.start();
		t2.start();
	}
}
* synchronized but get irregular o/p because of different object.
conclusion:
===========
* if multiple threads operating on the same java object then synchronization is required else not.

case3:
======
class level lock:
=================
* Every class in java has unique lock, which is nothing but class level lock.
* If a thread wants to executes "static sync method" then thread required class level lock.
* Once thread got class level lock then this allowed to execute any static sync method after tahat release.


class Display{
	public static synchronized void wish(String name){
		for(int i=0;i<10;i++){
			syso("good morning");
			try{
				Thread.sleep(2000);
			}
			catch(Interrupt Exception e){
			}
			syso(name);
		}
	}
}

synchronized block:
===================
* if very few lines of code required synchronization then it is not recomended declare entire method synchronized. we have to enclose those few lines of code by using syncronized block.
1. to get lock of current object:
=================================
synchronized(this){

}
ex:
===
class Display {
    public void show(String msg) {
        synchronized(this) {  // object-level lock
            for (int i = 1; i <= 3; i++) {
                System.out.println(msg + " - " + i);
                try { Thread.sleep(500); } catch (InterruptedException e) {}
            }
        }
    }
}

public class ObjectLockDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        Display d2 = new Display(); // second object

        Runnable task1 = () -> d1.show("Thread A");
        Runnable task2 = () -> d2.show("Thread B");

        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);

        t1.start();
        t2.start();
    }
}


2. to get class lock:
============================
synchronized(Display.class){

}
ex:
===
class Display {
    public void show(String msg) {
        synchronized(Display.class) {  // class-level lock
            for (int i = 1; i <= 3; i++) {
                System.out.println(msg + " - " + i);
                try { Thread.sleep(500); } catch (InterruptedException e) {}
            }
        }
    }
}

public class ClassLockDemo {
    public static void main(String[] args) {
        Display d1 = new Display();
        Display d2 = new Display(); // second object

        Runnable task1 = () -> d1.show("Thread A");
        Runnable task2 = () -> d2.show("Thread B");

        Thread t1 = new Thread(task1);
        Thread t2 = new Thread(task2);

        t1.start();
        t2.start();
    }
}


* lock concept is applicable for object types & class types but not primitive.
* hence we can't pass primitive types as argument to synchronized block else get CE 

* IF multiple thread operating simentaniously on same java obbject then there is a chance of data inconsistency problem this is called "Race Condition".

Synchronized statement:
=======================
* The statement present in synchronized method & synchronized block is called Synchronized statements.

Inter thread communication:
===========================
* Two threads can communicate with each otherby using "wait()", "notify()"& "notifyAll()" methods.
* The thrad which is expecting the updation is responsible to call "wait()" method then immediately the thread entered into waiting state.
* the thread which is resposible to perform updation,after performing updation, its responsible for to call "notify()" method then waiting thread get the notification and continue its execution with those updated items.
* The wait(),  notify(), notifyall() present in object class but not in thread class because thread can call these method on any java object.

* to call wait(), notify() and notifyall() methods on any object thread should be owner of that object i,e the thread should has lock of that object i,e the thread should be inside the synchronized area.
* if we call outiside we will get RE: IlligalMonitoprStateException

* If thread calls wait() method on any object it immediately release lock of that perticular object and entered into waiting state.
* If a thread calls notify() method on any object it releases that object lock but not immediately
* expect wait(),notigy() and notifyAll() there is no other method where thread release the lock.

prototype:
==========
public final void wait() throws IE;
public final native void wait(long ms) throws IE;
public final void wait(long ms, int ns) throws IE;
public final native void notify();
public final native void notifyALl();

give exapmles with respect to sleep, join (not recomended way)

sleep:
======
class Task1 extends Thread {
	    int total = 0;
    public void run() {
        System.out.println("Task1: Starting work...");
        for(it i =0;i<100;i++){
			tootal+=i;
		}
        System.out.println("Task1: Work done.");
    }
}



public class SleepDemo {
    public static void main(String[] args) {
       Task1 t1 = new Task();
	   t1.start();
	   Thread.sleep(1000);
	   syso("Main thread: "+t1.total)
    }
}

join():
=======
class Task1 extends Thread {
int total = 0;
    public void run() {
        System.out.println("Task1: Starting work...");
        for(it i =0;i<100;i++){
			tootal+=i;
		}
        System.out.println("Task1: Work done.");
    }
}



public class SleepDemo {
    public static void main(String[] args) {
       Task1 t1 = new Task();
	   t1.start();
	   t1.join();
	   Thread.sleep(1000);
	   syso("Main thread: "+t1.total)
    }
}

* usign wait:
==============
class Task1 extends Thread {
	int total = 0;
    public void run() {
        synchronized(this){
			System.out.println("Task1: Starting work...");
			for(it i =0;i<100;i++){
				tootal+=i;
			}
			System.out.println("Task1: Work done.");
			this.notify();
		}
		
    }
}



public class SleepDemo {
    public static void main(String[] args) {
       Task1 t1 = new Task();
	   t1.start();
	   Synchronized(b){
			syso("Main callign wait");
			t1.wait();
	   }
	   syso("Main tread go tthe notification");
	   syso("Main thread: "+t1.total)
    }
}


* you can also use wait for some time if notification not get it then proceed wait(1000);


Difference between notify() and notifyAll():
============================================
* we can use notify() to give the notification for only one waiting thread. if multiple threads are waiting then only one thread will notify. and the remaining thread has to wait for further notification which thread be notified we can't expect it depends on jvm.

* we can use notifyAll() to give the notification to all waiting threads of a perticular object even though multiple thread notified but execution be performed one by one because of threads are required lock and only one lock is avilable.


Deadlock:
=========
* If two threads are waiting for each other for ever such type of infinite waitingg is called "deadlock".
* Synchronized keyword isonly reason for deadlock sutiation hence while using synchronized keyword we have totake special care.
* Thre are no resolution for deadlock but several prevention technique are avilable.

* simply first thread is waitign for lock hold by 2nd thread and 2nd thread waitign for lockk hold by 1st thread is called deadlock.

ex:
===
class A{
	public synchronized void d1(B b){
		syso("Threa 1 starts execution of d1()");
		try{
			Thread.sleep(6000);
		}
		catch{
		}
		syso("Thread 1 tryng to call last() method");
		b.last();
	}
	public synchronized void last(){
		syso("Thread A this is last() method")
	}
}
class B{
	public synchronized void d2(A a){
		syso("Threa 1 starts execution of d2()");
		try{
			Thread.sleep(6000);
		}
		catch{
		}
		syso("Thread 1 tryng to call last() method");
		a.last();
	}
		public synchronized void last(){
		syso("Thread B this is last() method")
	}
}

class Deadlock extends Thread{
	A a = new A();
	B b = new B();
	public void m1(){
		this.start();
		a.d1(b);
	}
	public void run(){
		b.d2(a);
	}
	psvm(){
		Deadlock d = new Deadlock();
		d.m1();
	}
}

* I the above ex f we remove at least one sync keyword then the prg won't enter deadlock situation.

DeakLock V/S Starvation:
========================
* Long waiting thread where waiting nerver ends is called deadlock.
* Long waiting thread where waiting ends at certain point is called starvaton.

for ex: low priority thread need to wait until completig of high priority thread.

Daemon Threads:
===============
* The thread which is executing in background are called Daemon thread.

ex:
===
1. grabage collector
2. Signal Dispature
3. Attach Listner

* The main objective of daemon thread give support for non-daemon thread(main thread).

for ex:
=======
* if main thread runs wit low memory then jvm runs with grabage collector to destro use less memory.


* usually daemon thread having low memory but based on our requirement the daemon thread can run with high priority also.

public boolean isDaemon();
public void setDaemon(boolean b);

* but changing daemon nature is possible before starting of a thread only, afer startign thread if we are trying to change a daemon native then we will get run time execption saying "IllegalThreadStateException"

Default nature of thread:
=========================
* By default main thread is non-daemon & for all threads the daemon nature will inherited from parent ot child i,e  if the parent si daemon then child thread is also daemon.

Note:
=====
* itis impossible ot change the daemon nature of main thread because it is already stated by jvm

public class MainThreadDaemonExample {
    public static void main(String[] args) {
        Thread mainThread = Thread.currentThread();
        
        System.out.println("Is main thread daemon before setting? " + mainThread.isDaemon());
        
        try {
            mainThread.setDaemon(true); // attempt to make main thread daemon
        } catch (IllegalThreadStateException e) {
            System.out.println("Cannot make main thread daemon: " + e);
        }
        
        System.out.println("Is main thread daemon after attempt? " + mainThread.isDaemon());
		
		MyThrewad t = new MyThread();
		syso(t.isDaemon());
		t.setDaemon(true);
		t.start();
    }
}


* when ever the last non Daemon thread terminates automatically all Daemon threads will be terminated irrespective of thread position.

class MyDaemonThread extends Thread {
    public void run() {
        for (int i = 1; i <= 10; i++) {
            System.out.println("Daemon Thread working... step " + i);
            try {
                Thread.sleep(1000); // simulate some work
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Daemon Thread finished!");
    }
}

public class DaemonTerminationDemo {
    public static void main(String[] args) {
        MyDaemonThread t = new MyDaemonThread();
        t.setDaemon(true);  // must set before starting thread
        t.start();
        
        System.out.println("Main (user) thread sleeping for 3 seconds...");
        try {
            Thread.sleep(3000); // user thread finishes quickly
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Main thread ends. JVM will now terminate daemon thread!");
    }
}

how to stop a thread:
=====================
* we can stop a thread execution by using "stop()" method of thread.

public void stop();

* then thread enter into dead state
* it is depricated but not recomended.

How to suspend and resume thread:
=================================
* we can suspend a thread using suspend method of thread class then immediately the thread will enter into suspended state.

* we can resume a suspended thread by suing resume() method of the thread class then suspended thread cna continue its execution.

public void suspend();
public void resume();

* this methods are depricated not recomende  to use.

compplete life cycle of thread:
===============================